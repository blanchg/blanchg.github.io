<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>
      	<script src="combinations.js"></script>

		<script src="three.js"></script>
      	<script src="dat.gui.js"></script>
		<script src="OrbitControls.js"></script>

		<script src="Detector.js"></script>
		<script src="stats.min.js"></script>
		<script src="coplanar.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( 300.0 / -mvPosition.z);

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			// uniform vec3 color;
			// uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				// gl_FragColor = vec4( color * vColor, 1.0 );

				gl_FragColor = vec4( vColor, 1.0 ); //gl_FragColor * texture2D( texture, gl_PointCoord );

				// if ( gl_FragColor.a < ALPHATEST ) discard;

			}

		</script>


		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var renderer, scene, camera, stats;

			var particles, uniforms;

			var PARTICLE_SIZE = 5;
			var n = 13;

			var raycaster, intersects;
			var mouse, INTERSECTED;
			var mouseDown = false;
			var axisgroup;
			var axisHelper;
	        var axisHelper2;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var mouseY = 0;
			var mouseYOnMouseDown = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var material;
			var geometry;
			var index = [];
			var selected = [];
			var controls;

			var gui = new dat.GUI({
			    height : 1 * 32 - 1
			});
			var params = {
			    size: n,
			    solution: '0',
			    moves: ''
			};

			gui.add(params, 'size').min(2).max(97).step(1).name('N').onFinishChange(function(value) {
			    value = parseInt(value);
			    if (value > 97)
			        return;
			  	buildGeometry(geometry, index, selected);
			});

			// gui.add(params, 'run').name('Search');
			// gui.add(params, 'stop').name('Stop');
			// gui.add(params, 'entry').name('Print Entry');
			gui.add(params, 'solution').name('Solution Size');
			gui.add(params, 'moves').name('Valid Moves');
			// gui.add(params, 'submitEntry').name('View Entry');

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 1, 1000000 );
				camera.position.z = 150;
				camera.position.x = 10;
				camera.position.y = 10;
				camera.lookAt(new THREE.Vector3(0, 0, 0));


				geometry = buildGeometry(new THREE.BufferGeometry(), index, selected)

				//
				console.log("Creating ShaderMaterial");
				material = new THREE.ShaderMaterial( {

					// uniforms: {
					// 	color:   { type: "c", value: new THREE.Color( 0xffffff ) },
					// 	texture: { type: "t", value: new THREE.TextureLoader().load( "disc.png" ) }
					// },
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

					alphaTest: 0.9,

				} );


				//
				console.log("Creating Points");
				particles = new THREE.Points( geometry, material );


				axisgroup = new THREE.Object3D();
				axisgroup.add(particles);
				scene.add( axisgroup );
		         
		        //load mesh 
		        // var loader = new THREE.JSONLoader();
		        // loader.load('models/cube.js', modelLoadedCallback);

		        axisHelper = new THREE.AxisHelper(6000);
		        axisHelper.rotation.x = Math.PI/2;
		        // axisHelper.rotation.z = Math.PI/2;
		        axisHelper2 = new THREE.AxisHelper(6000);
		        axisgroup.add(axisHelper);
		        axisHelper2.scale.x = -1;
		        axisHelper2.scale.y = -1;
		        axisHelper2.scale.z = -1;
		        axisHelper2.rotation.x = Math.PI/2;
		        // axisHelper2.rotation.z = Math.PI/2;
		        axisgroup.add(axisHelper2);

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				//controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
				controls.enableDamping = false;
				controls.dampingFactor = 0.1;
				controls.enableZoom = true;
				controls.mouseButtons = { ORBIT: THREE.MOUSE.MIDDLE, ZOOM: -1, PAN: THREE.MOUSE.MIDDLE };
				controls.shiftKeys = { ORBIT: false, ZOOM: false, PAN: true };
				controls.addEventListener( 'change', onOrbitChange, false );
				controls.minPolarAngle = Math.PI * 0.1; // radians
				controls.maxPolarAngle = Math.PI * 0.9; // radians

				params.resetCamera = function() {
					controls.reset();
				}
				gui.add(params, 'resetCamera').name('Reset Camera');

				// controls.pan(10, -10);

				//

				raycaster = new THREE.Raycaster();
				raycaster.params.Points.threshold = 0.5;
				mouse = new THREE.Vector2();

				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );
		        container.addEventListener( 'mouseup', onDocumentMouseUp, false );
			}

			function onOrbitChange(event) {
				axisHelper.position.copy(controls.target);
				axisHelper2.position.copy(controls.target);
			}

			function buildGeometry(geometry, index, selected) {

				//
				// console.log("Building geometry");
				// var geometry1 = new THREE.BoxGeometry( 300, 300, 300, 300, 300, 300 );
				// console.log("Getting vertices");
				// var vertices = geometry1.vertices;

				n = params.size;
				var size = n*n*n;

				index.length = size;
				selected.length = 0;

				var positions = new Float32Array( size * 3 );
				var colors = new Float32Array( size * 3 );
				var sizes = new Float32Array( size );

				// console.log("Generating vertices")

				var j = 0;
				var k = 1;
				var l = 2;
				var color = new THREE.Color();
				var spacing = n * 2;
				var startPos = -(n-1)/2 * spacing;
				var endPos = startPos + n * spacing;
				var x = startPos;
				var y = startPos;
				var z = startPos;


				// console.log("Start To End", startPos, endPos, n);

				for ( var i = 0; true; i ++ ) {

					positions[j] = x;
					positions[k] = y;
					positions[l] = z;
					// console.log("XYZ",x,y,z)

					index[i] = 0;

					// color.setHSL( Math.sin(x/n), Math.sin(y/n) * 0.5 + 0.5, Math.sin(z/n) * 0.5 + 0.5); //0.01 + 0.1 * ( i / l ), 1.0, 0.5 );

					color.setRGB( 0, 0.8, 0);
					color.toArray( colors, i * 3 );

					sizes[ i ] = PARTICLE_SIZE * 0.5;

					j += 3;
					k += 3;
					l += 3;

					x+=spacing;
					if (x >= endPos) {
						x = startPos;
						y+=spacing;
						if (y >= endPos) {
							y = startPos;
							z+=spacing;
							if (z >= endPos) {
								// console.log("Shouldn't get here :(", i, size);
								break;
							}
						}
					}

				}

				// console.log("XYZ",x,y,z);

				// console.log("Creating BufferGeometry");

				// console.log("Set position");
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				// console.log("Set customColor");
				geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				// console.log("Set size")
				geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

				return geometry;

			}


			function onDocumentMouseUp( event ) {

			    mouse.x = ( ( event.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width ) * 2 - 1;
			    mouse.y = - ( ( event.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height ) * 2 + 1;

			    raycaster.setFromCamera(mouse, camera);

			    // create an array containing all objects in the scene with which the ray intersects
			    var intersects = raycaster.intersectObject( particles );
			    
			    // if there is one (or more) intersections
			    if ( intersects.length > 0 )
			    {
					var attributes = geometry.attributes;
					var colors = attributes.customColor;
					var positions = attributes.position.array;
			    	var hit = intersects[0];
			    	console.log("Index:", hit.index);
			    	console.log("Particle:",  positions[hit.index * 3], positions[hit.index * 3 + 1], positions[hit.index * 3 + 2]);

			    	if (toggle(hit.index)) {
						colors.setXYZ(hit.index, 0, 0.8, 0);
			    	} else {
						colors.setXYZ(hit.index, 0.8, 0, 0);
					}
					colors.needsUpdate = true;
			        // toggleVertex(intersects[0].object)

			        // updateCalculations();

			    }

			}

			function toggle(i) {
				if (index[i] == 0) {
					index[i] = 1;
					selected.push(i);
					return true;
				} else {
					index[i] = 0;
					var pos = selected.indexOf(i);
					if (pos != -1)
						selected.splice(pos, 1);
					return false;
				}
			}			

			function onWindowResize() {

			    windowHalfX = window.innerWidth / 2;
			    windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update();
				render();
				stats.update();

			}

			function render() {

				// particles.rotation.x += 0.0005;
				// particles.rotation.y += 0.01;

				// var geometry = particles.geometry;
				// var attributes = geometry.attributes;

				// raycaster.setFromCamera( mouse, camera );

				// intersects = raycaster.intersectObject( particles );

				// if ( intersects.length > 0 ) {

				// 	if ( INTERSECTED != intersects[ 0 ].index ) {

				// 		attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;

				// 		INTERSECTED = intersects[ 0 ].index;

				// 		attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * 1.25;
				// 		attributes.size.needsUpdate = true;

				// 	}

				// } else if ( INTERSECTED !== null ) {

				// 	attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;
				// 	attributes.size.needsUpdate = true;
				// 	INTERSECTED = null;

				// }


			    // //horizontal rotation   
			    // axisgroup.rotation.y += ( targetRotationX - axisgroup.rotation.y ) * 0.1;

			    // //vertical rotation 
			    // finalRotationY = (targetRotationY - axisgroup.rotation.x); 

			     
			    // if (axisgroup.rotation.x <= 1 && axisgroup.rotation.x >= -1) {

			    //     axisgroup.rotation.x += finalRotationY * 0.1;
			    // }
			    // if (axisgroup.rotation.x > 1) {

			    //     axisgroup.rotation.x = 1;
			    // }
			    // else if (axisgroup.rotation.x < -1) {

			    //     axisgroup.rotation.x = -1;
			    // }


			    // gridgroup.rotation.y = axisgroup.rotation.y;
			    // connectorgroup.rotation.y = axisgroup.rotation.y;
			    // gridgroup.rotation.x = axisgroup.rotation.x;
			    // connectorgroup.rotation.x = axisgroup.rotation.x;

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>