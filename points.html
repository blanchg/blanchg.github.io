<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>
      	<script src="combinations.js"></script>

		<script src="three.js"></script>
		<script src="GPUPicker.js"></script>
      	<script src="dat.gui.js"></script>
		<script src="OrbitControls.js"></script>

		<script src="Detector.js"></script>
		<script src="stats.min.js"></script>
		<script src="coplanar.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute vec3 customColor;

			uniform float size;
			uniform float scale;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( scale / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			// uniform vec3 color;
			// uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				// gl_FragColor = vec4( color * vColor, 1.0 );

				gl_FragColor = vec4( vColor, 1.0 ); //gl_FragColor * texture2D( texture, gl_PointCoord );

				// if ( gl_FragColor.a < ALPHATEST ) discard;

			}

		</script>


		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var renderer, scene, camera, stats;

			var particles, uniforms;
			var colors;

			var PARTICLE_SIZE = 5;
			var n = 2;

			var raycaster, intersects, gpuPicker, pickerMouse;
			var mouse, INTERSECTED;
			var mouseDown = false;
			var axisgroup;
			var axisHelper;
	        var axisHelper2;

	        var debug = false;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var mouseY = 0;
			var mouseYOnMouseDown = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var material;
			var geometry;
			var index = [];
			var selected = [];
			var names = [];
			var controls;

			var gui = new dat.GUI({
			    height : 1 * 32 - 1
			});
			var params = {
			    size: n,
			    solution: '0',
			    moves: ''
			};

			gui.add(params, 'size').min(2).max(97).step(1).name('N').onFinishChange(function(value) {
			    value = parseInt(value);
			    if (value > 97)
			        return;
			  	buildGeometry(geometry, index, selected, names);
			  	colors = geometry.getAttribute('customColor');
			  	gpuPicker.setScene(scene);
			});

			// gui.add(params, 'run').name('Search');
			// gui.add(params, 'stop').name('Stop');
			// gui.add(params, 'entry').name('Print Entry');
			gui.add(params, 'solution').name('Solution Size');
			gui.add(params, 'moves').name('Valid Moves');
			// gui.add(params, 'submitEntry').name('View Entry');

			function updateGUI() {
			      // Iterate over all controllers
			      for (var i in gui.__controllers) {
			        gui.__controllers[i].updateDisplay();
			      }

			}

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 150;
				camera.position.x = 10;
				camera.position.y = 10;
				camera.lookAt(new THREE.Vector3(0, 0, 0));


				geometry = buildGeometry(new THREE.BufferGeometry(), index, selected, names);
				colors = geometry.getAttribute('customColor');

				//
				console.log("Creating ShaderMaterial");
				material = new THREE.ShaderMaterial( {

					// uniforms: {
					// 	color:   { type: "c", value: new THREE.Color( 0xffffff ) },
					// 	texture: { type: "t", value: new THREE.TextureLoader().load( "disc.png" ) }
					// },
					uniforms: {
						size: {
							type: "f",
							value: 2,
						},
						scale: {
							type: "f",
							value: 400,
						}
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

					alphaTest: 0.9,

				} );


				//
				console.log("Creating Points");
				particles = new THREE.Points( geometry, material );
				particles.name = "particles";



				axisgroup = new THREE.Object3D();
				axisgroup.add(particles);
				scene.add( axisgroup );

				// var geometry = new THREE.SphereGeometry( 5, 32, 32 );
				// var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
				// var sphere = new THREE.Mesh( geometry, material );
				// scene.add( sphere );
		         
		        //load mesh 
		        // var loader = new THREE.JSONLoader();
		        // loader.load('models/cube.js', modelLoadedCallback);

		        axisHelper = new THREE.AxisHelper(6000);
		        axisHelper.rotation.x = Math.PI/2;
		        // axisHelper.rotation.z = Math.PI/2;
		        axisHelper2 = new THREE.AxisHelper(6000);
		        axisgroup.add(axisHelper);
		        axisHelper2.scale.x = -1;
		        axisHelper2.scale.y = -1;
		        axisHelper2.scale.z = -1;
		        axisHelper2.rotation.x = Math.PI/2;
		        // axisHelper2.rotation.z = Math.PI/2;
		        axisgroup.add(axisHelper2);

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				//controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
				controls.enableDamping = false;
				controls.dampingFactor = 0.1;
				controls.enableZoom = true;
				controls.mouseButtons = { ORBIT: THREE.MOUSE.MIDDLE, ZOOM: -1, PAN: THREE.MOUSE.MIDDLE };
				controls.shiftKeys = { ORBIT: false, ZOOM: false, PAN: true };
				controls.addEventListener( 'change', onOrbitChange, false );
				controls.minPolarAngle = Math.PI * 0.1; // radians
				controls.maxPolarAngle = Math.PI * 0.9; // radians

				params.resetCamera = function() {
					controls.reset();
				}
				gui.add(params, 'resetCamera').name('Reset Camera');

				// controls.pan(10, -10);

				//

				raycaster = new THREE.Raycaster();
				// raycaster.params.Points.threshold = 0.5;
				mouse = new THREE.Vector2();
				pickerMouse = new THREE.Vector2();
				gpuPicker = new THREE.GPUPicker({renderer:renderer, debug: true});
				gpuPicker.setFilter(function (object) {return object.name == "particles";});
				gpuPicker.setScene(scene);
				gpuPicker.setCamera(camera);

				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );
		        container.addEventListener( 'mouseup', onDocumentMouseUp, false );
			}


			document.addEventListener('keyup', function(e) {
			    if (e.keyCode == 27)
			        clearAll();

			    if (e.keyCode == 68)
			    	debug = !debug;

			});

			function onOrbitChange(event) {
				axisHelper.position.copy(controls.target);
				axisHelper2.position.copy(controls.target);
				gpuPicker.needUpdate = true;
			}

			function buildGeometry(geometry, index, selected, names) {

				//
				// console.log("Building geometry");
				// var geometry1 = new THREE.BoxGeometry( 300, 300, 300, 300, 300, 300 );
				// console.log("Getting vertices");
				// var vertices = geometry1.vertices;

				n = params.size;
				var size = n*n*n;

				index.length = size;
				selected.length = 0;
				names.length = 0;

				var positions = new Float32Array( size * 3 );
				var colors = new Float32Array( size * 3 );
				var sizes = new Float32Array( size );

				// console.log("Generating vertices")

				var j = 0;
				var k = 1;
				var l = 2;
				var color = new THREE.Color();
				var spacing = n * 2;
				var startPos = 0;
				var offset = -(n-1)/2 * spacing;
				var endPos = startPos + n;
				var x = startPos;
				var y = startPos;
				var z = startPos;


				// console.log("Start To End", startPos, endPos, n);

				for ( var i = 0; true; i ++ ) {

					positions[j] = x * spacing + offset;
					positions[l] = y * spacing + offset;
					positions[k] = z * spacing + offset;
					// console.log("XYZ",x,y,z)

					names[i] = xyzStr(x, n-y-1, z);

					index[i] = 0;

					// color.setHSL( Math.sin(x/n), Math.sin(y/n) * 0.5 + 0.5, Math.sin(z/n) * 0.5 + 0.5); //0.01 + 0.1 * ( i / l ), 1.0, 0.5 );

					color.setRGB( 0, 0.8, 0);
					color.toArray( colors, i * 3 );

					sizes[ i ] = PARTICLE_SIZE * 0.5;

					j += 3;
					k += 3;
					l += 3;

					x+=1;
					if (x >= endPos) {
						x = startPos;
						y+=1;
						if (y >= endPos) {
							y = startPos;
							z+=1;
							if (z >= endPos) {
								// console.log("Shouldn't get here :(", i, size);
								break;
							}
						}
					}

				}

				// console.log("XYZ",x,y,z);

				// console.log("Creating BufferGeometry");

				// console.log("Set position");
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				// console.log("Set customColor");
				geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				// console.log("Set size")
				geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

				delete geometry.__pickingGeometry;

				return geometry;

			}


			function onDocumentMouseUp( event ) {

				if (event.button !== 0)
					return;

			    mouse.x = ( ( event.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width ) * 2 - 1;
			    mouse.y = - ( ( event.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height ) * 2 + 1;

			    pickerMouse.x = event.clientX;
			    pickerMouse.y = event.clientY;

			    raycaster.setFromCamera(mouse, camera);

			    // create an array containing all objects in the scene with which the ray intersects
			    // var intersects = raycaster.intersectObject( particles );

			    var intersect = gpuPicker.pick(pickerMouse, raycaster);
			    
			    // console.log("I", intersect);
			    // if there is one (or more) intersections
			    if ( intersect )
			    {
					var attributes = geometry.attributes;
					var colors = attributes.customColor;
					var positions = attributes.position.array;
			    	console.log("Index:", intersect.index);
			    	console.log("Particle:",  positions[intersect.index * 3], positions[intersect.index * 3 + 1], positions[intersect.index * 3 + 2]);

					toggle(intersect.index);
					colors.needsUpdate = true;
			        // toggleVertex(intersects[0].object)

			        // updateCalculations();

			    }

			}

			function toggle(i) {
				if (isVertexSelected(i)) {
					clearVertex(i);
				} else {
					selectVertex(i);
				}
			}

			function isVertexSelected(i) {
				return index[i] == 1;
			}

			function selectVertex(i) {
				index[i] = 1;
				colors.setXYZ(i, 0.8, 0, 0);
				selected.push(i);
			}

			function clearVertex(i) {
				index[i] = 0;
				colors.setXYZ(i, 0, 0.8, 0);
				var pos = selected.indexOf(i);
				if (pos != -1)
					selected.splice(pos, 1);

			}

			function clearAll() {
			    // selected.forEach(function (i) {
			    // 	console.log("Clearing", i);
			    //     clearVertex(i);
			    // });
			    for (var i = selected.length - 1; i >= 0; i--) {
			    	clearVertex(selected[i]);
			    }
			    colors.needsUpdate = true;
			    console.log("Cleared vertices");
			}

			function getSelected() {
				return selected;
			}

			function onWindowResize() {

			    windowHalfX = window.innerWidth / 2;
			    windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				gpuPicker.resizeTexture( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update();
				render();
				stats.update();

			}

			function render() {

				// particles.rotation.x += 0.0005;
				// particles.rotation.y += 0.01;

				// var geometry = particles.geometry;
				// var attributes = geometry.attributes;

				// raycaster.setFromCamera( mouse, camera );

				// intersects = raycaster.intersectObject( particles );

				// if ( intersects.length > 0 ) {

				// 	if ( INTERSECTED != intersects[ 0 ].index ) {

				// 		attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;

				// 		INTERSECTED = intersects[ 0 ].index;

				// 		attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * 1.25;
				// 		attributes.size.needsUpdate = true;

				// 	}

				// } else if ( INTERSECTED !== null ) {

				// 	attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;
				// 	attributes.size.needsUpdate = true;
				// 	INTERSECTED = null;

				// }


			    // //horizontal rotation   
			    // axisgroup.rotation.y += ( targetRotationX - axisgroup.rotation.y ) * 0.1;

			    // //vertical rotation 
			    // finalRotationY = (targetRotationY - axisgroup.rotation.x); 

			     
			    // if (axisgroup.rotation.x <= 1 && axisgroup.rotation.x >= -1) {

			    //     axisgroup.rotation.x += finalRotationY * 0.1;
			    // }
			    // if (axisgroup.rotation.x > 1) {

			    //     axisgroup.rotation.x = 1;
			    // }
			    // else if (axisgroup.rotation.x < -1) {

			    //     axisgroup.rotation.x = -1;
			    // }


			    // gridgroup.rotation.y = axisgroup.rotation.y;
			    // connectorgroup.rotation.y = axisgroup.rotation.y;
			    // gridgroup.rotation.x = axisgroup.rotation.x;
			    // connectorgroup.rotation.x = axisgroup.rotation.x;

				renderer.render( debug?gpuPicker.pickingScene:scene, camera );

			}

		</script>

	</body>

</html>